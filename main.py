import heapq
import random
import datetime
from collections import deque
from typing import Dict, List, Optional, Tuple

# Classe base para n√≥s utilizados em estruturas de dados
class No:
    def __init__(self, dados):
        self.dados, self.proximo, self.esquerda, self.direita = dados, None, None, None

# Lista ligada para hist√≥rico de a√ß√µes das equipes
class ListaLigada:
    def __init__(self):
        self.cabeca, self.tamanho = None, 0
    
    def inserir_inicio(self, dados):
        novo_no = No(dados)
        novo_no.proximo, self.cabeca, self.tamanho = self.cabeca, novo_no, self.tamanho + 1
    
    def listar(self):
        elementos, atual = [], self.cabeca
        while atual:
            elementos.append(atual.dados)
            atual = atual.proximo
        return elementos

# √Årvore bin√°ria para organizar regi√µes por prioridade de risco
class ArvoreRegiao:
    def __init__(self):
        self.raiz = None
    
    def inserir(self, regiao, prioridade):
        if not self.raiz:
            self.raiz = No({'regiao': regiao, 'prioridade': prioridade})
        else:
            self._inserir_recursivo(self.raiz, regiao, prioridade)
    
    def _inserir_recursivo(self, no, regiao, prioridade):
        lado = 'esquerda' if prioridade < no.dados['prioridade'] else 'direita'
        if getattr(no, lado) is None:
            setattr(no, lado, No({'regiao': regiao, 'prioridade': prioridade}))
        else:
            self._inserir_recursivo(getattr(no, lado), regiao, prioridade)
    
    # Busca bin√°ria para encontrar regi√£o por prioridade
    def busca_binaria_regiao(self, prioridade_alvo):
        return self._buscar_recursivo(self.raiz, prioridade_alvo)
    
    def _buscar_recursivo(self, no, prioridade_alvo):
        if not no: return None
        if no.dados['prioridade'] == prioridade_alvo: return no.dados
        return self._buscar_recursivo(no.esquerda if prioridade_alvo < no.dados['prioridade'] else no.direita, prioridade_alvo)
    
    def listar_em_ordem(self):
        resultado = []
        self._em_ordem_recursivo(self.raiz, resultado)
        return resultado
    
    def _em_ordem_recursivo(self, no, resultado):
        if no:
            self._em_ordem_recursivo(no.esquerda, resultado)
            resultado.append(no.dados)
            self._em_ordem_recursivo(no.direita, resultado)

# Grafo para representar conex√µes entre regi√µes e calcular rotas
class GrafoRegioes:
    def __init__(self):
        self.vertices, self.coordenadas = {}, {}
    
    def adicionar_vertice(self, regiao, coordenadas=None):
        if regiao not in self.vertices:
            self.vertices[regiao] = {}
            if coordenadas: self.coordenadas[regiao] = coordenadas
    
    # Adiciona conex√£o bidirecional entre duas regi√µes
    def adicionar_aresta(self, regiao1, regiao2, peso):
        self.adicionar_vertice(regiao1), self.adicionar_vertice(regiao2)
        self.vertices[regiao1][regiao2] = self.vertices[regiao2][regiao1] = peso
    
    # Algoritmo de Dijkstra para encontrar menor caminho entre regi√µes
    def dijkstra(self, origem, destino):
        if origem not in self.vertices or destino not in self.vertices: 
            return None, float('inf')
        
        # Inicializa√ß√£o das estruturas do algoritmo
        distancias = {v: float('inf') for v in self.vertices}
        predecessores = {v: None for v in self.vertices}
        visitados = set()
        
        distancias[origem] = 0
        heap = [(0, origem)]  # Min-heap para processar v√©rtices por dist√¢ncia
        
        while heap:
            dist_atual, vertice_atual = heapq.heappop(heap)
            
            if vertice_atual in visitados:
                continue
            
            visitados.add(vertice_atual)
            
            # Otimiza√ß√£o: parar quando chegamos ao destino
            if vertice_atual == destino:
                break
            
            # Relaxamento das arestas
            for vizinho, peso in self.vertices[vertice_atual].items():
                if vizinho not in visitados:
                    nova_dist = dist_atual + peso
                    if nova_dist < distancias[vizinho]:
                        distancias[vizinho] = nova_dist
                        predecessores[vizinho] = vertice_atual
                        heapq.heappush(heap, (nova_dist, vizinho))
        
        # Reconstru√ß√£o do caminho
        if distancias[destino] == float('inf'):
            return None, float('inf')
        
        caminho = []
        vertice_atual = destino
        while vertice_atual is not None:
            caminho.append(vertice_atual)
            vertice_atual = predecessores[vertice_atual]
        
        caminho.reverse()
        
        # Valida√ß√£o do caminho
        if caminho[0] != origem:
            return None, float('inf')
        
        return caminho, distancias[destino]

    # Visualiza√ß√£o das conex√µes do grafo
    def listar_conexoes(self):
        print("\nüó∫Ô∏è MAPA DE CONEX√ïES ENTRE REGI√ïES:\n" + "-" * 50)
        for regiao, conexoes in self.vertices.items():
            print(f"üìç {regiao}:")
            for vizinho, peso in conexoes.items():
                print(f"   ‚Üí {vizinho} (dist√¢ncia: {peso} unidades)")
            print()
        
        # Estat√≠sticas do grafo
        total_regioes = len(self.vertices)
        total_conexoes = sum(len(c) for c in self.vertices.values()) // 2
        conectividade_media = sum(len(c) for c in self.vertices.values()) / total_regioes
        
        print("üìä ESTAT√çSTICAS DO MAPA:\n" + "-" * 30)
        print(f"üåç Total de regi√µes: {total_regioes}")
        print(f"üîó Total de conex√µes: {total_conexoes}")
        print(f"üìà Conectividade m√©dia: {conectividade_media:.1f} conex√µes por regi√£o")
        
        print("\nüîó CONECTIVIDADE DAS REGI√ïES:\n" + "-" * 35)
        for regiao, conexoes in self.vertices.items():
            conexoes_formatadas = ", ".join(conexoes.keys())
            print(f"üèûÔ∏è {regiao}:")
            print(f"   üîó Conectada com: {conexoes_formatadas}")
            print(f"   üìä Total de conex√µes: {len(conexoes)}")
            print()

# Classe para representar uma ocorr√™ncia de queimada
class Ocorrencia:
    def __init__(self, id_ocorrencia, regiao, severidade, coordenadas, descricao=""):
        self.id, self.regiao, self.severidade = id_ocorrencia, regiao, severidade
        self.coordenadas, self.descricao = coordenadas, descricao
        self.timestamp, self.status = datetime.datetime.now(), "PENDENTE"
        self.equipe_responsavel, self.acoes_realizadas = None, []
    
    # Compara√ß√£o para heap de prioridade (maior severidade = maior prioridade)
    def __lt__(self, other): return self.severidade > other.severidade
    def __str__(self): return f"Ocorr√™ncia {self.id} - {self.regiao} (Severidade: {self.severidade})"

# Classe para representar equipes de resposta
class Equipe:
    def __init__(self, id_equipe, nome, especializacao):
        self.id, self.nome, self.especializacao = id_equipe, nome, especializacao
        self.disponivel, self.localizacao_atual, self.historico_acoes = True, None, ListaLigada()
    
    def registrar_acao(self, acao):
        self.historico_acoes.inserir_inicio({
            'timestamp': datetime.datetime.now(),
            'acao': acao,
            'equipe_id': self.id
        })

# Sistema principal IVERN
class SistemaIVERN:
    def __init__(self):
        # Estruturas de dados principais
        self.fila_prioridade, self.pilha_desfazer, self.fila_processamento = [], deque(), deque()
        self.arvore_regioes, self.grafo_regioes = ArvoreRegiao(), GrafoRegioes()
        self.ocorrencias_ativas, self.equipes, self.regioes_risco = {}, {}, {}
        self.proximo_id_ocorrencia, self.proximo_id_equipe = 1, 1
        self._inicializar_sistema()
    
    # Configura√ß√£o inicial do sistema com equipes, regi√µes e conex√µes
    def _inicializar_sistema(self):
        # Cria√ß√£o das equipes padr√£o
        for nome, esp in [("Brigada Florestal Alpha", "TERRESTRE"), ("Squadr√£o A√©reo Beta", "AEREA"), ("Equipe Resgate Gamma", "RESGATE")]:
            self.adicionar_equipe(nome, esp)
        
        # Configura√ß√£o das regi√µes com n√≠veis de risco
        for regiao, prioridade in [("Mata Atl√¢ntica Sul", 8), ("Cerrado Central", 6), ("Amaz√¥nia Norte", 9), ("Pantanal", 7), ("Caatinga", 5)]:
            self.regioes_risco[regiao] = prioridade
            self.arvore_regioes.inserir(regiao, prioridade)
        
        # Coordenadas geogr√°ficas das regi√µes
        regioes_coords = {
            "Mata Atl√¢ntica Sul": (-23.5, -46.6),
            "Cerrado Central": (-15.8, -47.9),
            "Amaz√¥nia Norte": (-3.1, -60.0),
            "Pantanal": (-19.9, -56.1),
            "Caatinga": (-9.7, -40.5)
        }
        
        for regiao, coords in regioes_coords.items():
            self.grafo_regioes.adicionar_vertice(regiao, coords)
        
        # Defini√ß√£o das conex√µes entre regi√µes com dist√¢ncias
        for regiao1, regiao2, distancia in [
            ("Mata Atl√¢ntica Sul", "Cerrado Central", 12),
            ("Cerrado Central", "Pantanal", 8),
            ("Cerrado Central", "Amaz√¥nia Norte", 15),
            ("Amaz√¥nia Norte", "Caatinga", 20),
            ("Pantanal", "Caatinga", 18),
            ("Mata Atl√¢ntica Sul", "Pantanal", 10),
            ("Cerrado Central", "Caatinga", 14)
        ]:
            self.grafo_regioes.adicionar_aresta(regiao1, regiao2, distancia)
    
    # Inser√ß√£o de nova ocorr√™ncia com prioriza√ß√£o autom√°tica
    def inserir_nova_ocorrencia(self, regiao, severidade, coordenadas, descricao=""):
        ocorrencia = Ocorrencia(self.proximo_id_ocorrencia, regiao, severidade, coordenadas, descricao)
        heapq.heappush(self.fila_prioridade, ocorrencia)  # Heap para prioriza√ß√£o
        self.fila_processamento.append(ocorrencia)
        self.ocorrencias_ativas[ocorrencia.id] = ocorrencia
        self.pilha_desfazer.append(('INSERIR_OCORRENCIA', ocorrencia.id))
        self.proximo_id_ocorrencia += 1
        print(f"‚úÖ Nova ocorr√™ncia registrada: {ocorrencia}")
        return ocorrencia.id
    
    # Sistema de atendimento baseado em prioridade
    def atender_proxima_ocorrencia(self):
        if not self.fila_prioridade:
            print("‚ùå N√£o h√° ocorr√™ncias pendentes")
            return None
        
        ocorrencia = heapq.heappop(self.fila_prioridade)
        if not (equipe := self._encontrar_melhor_equipe(ocorrencia)):
            heapq.heappush(self.fila_prioridade, ocorrencia)
            print("‚ö†Ô∏è Nenhuma equipe dispon√≠vel no momento")
            return None
        
        # Atribui√ß√£o da equipe √† ocorr√™ncia
        ocorrencia.status, ocorrencia.equipe_responsavel = "EM_ATENDIMENTO", equipe.id
        equipe.disponivel = False
        equipe.registrar_acao(f"Iniciado atendimento da ocorr√™ncia {ocorrencia.id} em {ocorrencia.regiao}")
        self.pilha_desfazer.append(('ATENDER_OCORRENCIA', ocorrencia.id, equipe.id))
        print(f"üö® Atendimento iniciado: {ocorrencia} por {equipe.nome}")
        return ocorrencia.id
    
    # Algoritmo de sele√ß√£o da melhor equipe baseado em especializa√ß√£o e severidade
    def _encontrar_melhor_equipe(self, ocorrencia):
        equipes_disponiveis = [e for e in self.equipes.values() if e.disponivel]
        return next((e for e in equipes_disponiveis if 
                   (ocorrencia.severidade >= 8 and e.especializacao == "AEREA") or
                   (ocorrencia.severidade >= 6 and e.especializacao == "TERRESTRE")), 
                   equipes_disponiveis[0] if equipes_disponiveis else None)

    # Registro de a√ß√µes realizadas pelas equipes
    def registrar_acoes_realizadas(self, id_ocorrencia, acoes):
        if id_ocorrencia not in self.ocorrencias_ativas:
            print(f"‚ùå Ocorr√™ncia {id_ocorrencia} n√£o encontrada")
            return False
        
        ocorrencia = self.ocorrencias_ativas[id_ocorrencia]
        ocorrencia.acoes_realizadas.extend(acoes)
        
        if ocorrencia.equipe_responsavel:
            for acao in acoes:
                self.equipes[ocorrencia.equipe_responsavel].registrar_acao(f"Ocorr√™ncia {id_ocorrencia}: {acao}")
        
        print(f"üìù A√ß√µes registradas para ocorr√™ncia {id_ocorrencia}")
        return True
    
    def finalizar_ocorrencia(self, id_ocorrencia):
        if id_ocorrencia not in self.ocorrencias_ativas:
            print(f"‚ùå Ocorr√™ncia {id_ocorrencia} n√£o encontrada")
            return False
        
        ocorrencia = self.ocorrencias_ativas[id_ocorrencia]
        ocorrencia.status = "RESOLVIDO"
        
        # Libera√ß√£o da equipe para novos atendimentos
        if ocorrencia.equipe_responsavel:
            equipe = self.equipes[ocorrencia.equipe_responsavel]
            equipe.disponivel = True
            equipe.registrar_acao(f"Finalizada ocorr√™ncia {id_ocorrencia}")
        
        del self.ocorrencias_ativas[id_ocorrencia]
        print(f"‚úÖ Ocorr√™ncia {id_ocorrencia} finalizada")
        return True
    
    def listar_historico_equipe(self, id_equipe):
        if id_equipe not in self.equipes:
            print(f"‚ùå Equipe {id_equipe} n√£o encontrada")
            return []
        
        historico = self.equipes[id_equipe].historico_acoes.listar()
        print(f"\nüìã Hist√≥rico da {self.equipes[id_equipe].nome}:\n" + "-" * 50)
        for i, registro in enumerate(historico, 1):
            print(f"{i}. [{registro['timestamp'].strftime('%d/%m/%Y %H:%M:%S')}] {registro['acao']}")
        return historico
    
    def atualizar_status_ocorrencia(self, id_ocorrencia, novo_status):
        if id_ocorrencia not in self.ocorrencias_ativas:
            print(f"‚ùå Ocorr√™ncia {id_ocorrencia} n√£o encontrada")
            return False
        
        if novo_status not in ["PENDENTE", "EM_ATENDIMENTO", "RESOLVIDO"]:
            print("‚ùå Status inv√°lido. Use: PENDENTE, EM_ATENDIMENTO ou RESOLVIDO")
            return False
        
        ocorrencia = self.ocorrencias_ativas[id_ocorrencia]
        self.pilha_desfazer.append(('ATUALIZAR_STATUS', id_ocorrencia, ocorrencia.status))
        ocorrencia.status = novo_status
        print(f"üîÑ Status da ocorr√™ncia {id_ocorrencia} atualizado: {ocorrencia.status}")
        return True
    
    # Gera√ß√£o de relat√≥rios estat√≠sticos por regi√£o
    def gerar_relatorio_regiao(self, regiao=None):
        print(f"\nüìä RELAT√ìRIO DE ATENDIMENTO{' - ' + regiao if regiao else ''}\n" + "=" * 60)
        contadores = {}
        
        for ocorrencia in self.ocorrencias_ativas.values():
            if regiao is None or ocorrencia.regiao == regiao:
                if ocorrencia.regiao not in contadores:
                    contadores[ocorrencia.regiao] = {'ativas': 0, 'total_severidade': 0}
                contadores[ocorrencia.regiao]['ativas'] += 1
                contadores[ocorrencia.regiao]['total_severidade'] += ocorrencia.severidade
        
        for reg, dados in contadores.items():
            risco = self.regioes_risco.get(reg, 0)
            print(f"üåç {reg}:\n   ‚Ä¢ Ocorr√™ncias ativas: {dados['ativas']}\n   ‚Ä¢ Severidade m√©dia: {dados['total_severidade']/dados['ativas']:.1f}\n   ‚Ä¢ N√≠vel de risco: {risco}/10\n")
        
        print(f"üìà Total de ocorr√™ncias ativas: {sum(d['ativas'] for d in contadores.values())}")
        print("\nüë• STATUS DAS EQUIPES:\n" + "-" * 30)
        for equipe in self.equipes.values():
            print(f"‚Ä¢ {equipe.nome} ({equipe.especializacao}): {'üü¢ Dispon√≠vel' if equipe.disponivel else 'üî¥ Em atendimento'}")
    
    # Simula√ß√£o de chamadas para testes
    def simular_chamadas_aleatorias(self, quantidade=5):
        print(f"\nüé≤ SIMULANDO {quantidade} CHAMADAS ALEAT√ìRIAS\n" + "=" * 50)
        for i in range(quantidade):
            regiao = random.choice(list(self.regioes_risco.keys()))
            severidade = min(10, 3 + i + random.randint(0, 2))
            coordenadas = (round(random.uniform(-30, 5), 6), round(random.uniform(-70, -35), 6))
            descricao = random.choice([
                "Fuma√ßa avistada por morador local",
                "Foco de inc√™ndio detectado por sat√©lite",
                "Queimada n√£o controlada reportada",
                "Inc√™ndio florestal em expans√£o",
                "Emerg√™ncia ambiental cr√≠tica"
            ])
            self.inserir_nova_ocorrencia(regiao, severidade, coordenadas, descricao)
    
    def adicionar_equipe(self, nome, especializacao):
        equipe = Equipe(self.proximo_id_equipe, nome, especializacao)
        self.equipes[equipe.id], self.proximo_id_equipe = equipe, self.proximo_id_equipe + 1
        return equipe.id
    
    # Sistema de desfazer para opera√ß√µes cr√≠ticas
    def desfazer_ultima_acao(self):
        if not self.pilha_desfazer:
            print("‚ùå Nenhuma a√ß√£o para desfazer")
            return False
        
        acao = self.pilha_desfazer.pop()
        if acao[0] == 'ATUALIZAR_STATUS' and acao[1] in self.ocorrencias_ativas:
            self.ocorrencias_ativas[acao[1]].status = acao[2]
            print(f"‚Ü©Ô∏è Status da ocorr√™ncia {acao[1]} revertido para {acao[2]}")
        return True
    
    def buscar_ocorrencias_por_regiao(self, regiao):
        ocorrencias_regiao = [occ for occ in self.ocorrencias_ativas.values() if occ.regiao == regiao]
        print(f"üîç Encontradas {len(ocorrencias_regiao)} ocorr√™ncias em {regiao}")
        return ocorrencias_regiao
    
    def listar_regioes_por_prioridade(self):
        print("\nüó∫Ô∏è REGI√ïES POR PRIORIDADE:\n" + "-" * 40)
        for regiao_info in self.arvore_regioes.listar_em_ordem():
            print(f"‚Ä¢ {regiao_info['regiao']} (Prioridade: {regiao_info['prioridade']})")
    
    def status_sistema(self):
        print("\nüñ•Ô∏è STATUS DO SISTEMA IVERN\n" + "=" * 40)
        print(f"‚Ä¢ Ocorr√™ncias ativas: {len(self.ocorrencias_ativas)}\n‚Ä¢ Ocorr√™ncias na fila: {len(self.fila_prioridade)}")
        print(f"‚Ä¢ Equipes dispon√≠veis: {sum(1 for e in self.equipes.values() if e.disponivel)}\n‚Ä¢ Total de equipes: {len(self.equipes)}")
        print(f"‚Ä¢ A√ß√µes na pilha de desfazer: {len(self.pilha_desfazer)}")
    
    # C√°lculo de rota otimizada usando Dijkstra
    def calcular_rota_otima(self, regiao_origem, regiao_destino):
        caminho, distancia = self.grafo_regioes.dijkstra(regiao_origem, regiao_destino)
        if caminho is None:
            print(f"‚ùå N√£o h√° rota dispon√≠vel entre {regiao_origem} e {regiao_destino}")
            return None
        
        print(f"\nüõ£Ô∏è ROTA OTIMIZADA: {regiao_origem} ‚Üí {regiao_destino}\n" + "=" * 60)
        print(f"üìç Caminho: {' ‚Üí '.join(caminho)}\nüìè Dist√¢ncia total: {distancia} unidades")
        print(f"‚è±Ô∏è Tempo estimado: {distancia * 0.5:.1f} horas\nüöÅ Paradas intermedi√°rias: {len(caminho) - 2}")
        return {'caminho': caminho, 'distancia': distancia, 'tempo_estimado': distancia * 0.5}
    
    # Planejamento estrat√©gico de atendimento m√∫ltiplo
    def planejar_atendimento_multiplo(self, regiao_base):
        regioes_com_ocorrencias = list(set(occ.regiao for occ in self.ocorrencias_ativas.values() if occ.regiao != regiao_base))
        if not regioes_com_ocorrencias:
            print("‚ùå N√£o h√° ocorr√™ncias ativas para planejar rotas")
            return None
        
        if regiao_base not in self.grafo_regioes.vertices:
            print(f"‚ùå Regi√£o base {regiao_base} n√£o encontrada no mapa")
            return None
        
        rotas_priorizadas = []
        
        # C√°lculo de score para prioriza√ß√£o (severidade vs dist√¢ncia)
        for regiao in regioes_com_ocorrencias:
            caminho, distancia = self.grafo_regioes.dijkstra(regiao_base, regiao)
            
            if caminho is None or distancia == float('inf'):
                print(f"‚ö†Ô∏è N√£o h√° rota dispon√≠vel de {regiao_base} para {regiao}")
                continue
            
            ocorrencias_regiao = [occ for occ in self.ocorrencias_ativas.values() if occ.regiao == regiao]
            severidade_media = sum(occ.severidade for occ in ocorrencias_regiao) / len(ocorrencias_regiao)
            
            rotas_priorizadas.append({
                'regiao': regiao,
                'rota': {'caminho': caminho, 'distancia': distancia},
                'ocorrencias': len(ocorrencias_regiao),
                'severidade_media': severidade_media,
                'score': (severidade_media * 10) - distancia  # Score de prioriza√ß√£o
            })
        
        if not rotas_priorizadas:
            print("‚ùå Nenhuma rota v√°lida encontrada para as regi√µes com ocorr√™ncias")
            return None
        
        # Ordena√ß√£o por score de prioridade
        rotas_priorizadas.sort(key=lambda x: x['score'], reverse=True)
        print(f"\nüó∫Ô∏è PLANEJAMENTO DE ATENDIMENTO M√öLTIPLO\nüìç Base de opera√ß√µes: {regiao_base}\n" + "=" * 60)
        print("üéØ ORDEM DE ATENDIMENTO RECOMENDADA:\n" + "-" * 40)
        
        for i, info in enumerate(rotas_priorizadas, 1):
            print(f"{i}. {info['regiao']}\n   üìç Rota: {' ‚Üí '.join(info['rota']['caminho'])}")
            print(f"   üìè Dist√¢ncia: {info['rota']['distancia']} unidades\n   ‚è±Ô∏è Tempo: {info['rota']['distancia'] * 0.5:.1f}h")
            print(f"   üî• Ocorr√™ncias: {info['ocorrencias']} (severidade m√©dia: {info['severidade_media']:.1f})\n   üéØ Score de prioridade: {info['score']:.1f}\n")
        
        return rotas_priorizadas
    
    def visualizar_mapa_conexoes(self):
        self.grafo_regioes.listar_conexoes()
    
    # M√©todo de debug para verificar conectividade
    def debug_grafo(self):
        print("\nüîó VERIFICANDO CONECTIVIDADE DO GRAFO:")
        print(f"üìä Total de regi√µes: {len(self.grafo_regioes.vertices)}")
        print(f"üîó Total de conex√µes: {sum(len(c) for c in self.grafo_regioes.vertices.values()) // 2}")
        print(f"üìà Conectividade m√©dia: {sum(len(c) for c in self.grafo_regioes.vertices.values()) / len(self.grafo_regioes.vertices):.1f} conex√µes por regi√£o")
        
        print("\n‚úÖ Testando rotas principais:")
        rotas_teste = [
            ("Mata Atl√¢ntica Sul", "Amaz√¥nia Norte"),
            ("Cerrado Central", "Pantanal"),
            ("Caatinga", "Mata Atl√¢ntica Sul")
        ]
        
        for origem, destino in rotas_teste:
            caminho, dist = self.grafo_regioes.dijkstra(origem, destino)
            if caminho:
                print(f"   ‚úì {origem} ‚Üí {destino}: {dist} unidades ({len(caminho)-1} conex√µes)")
            else:
                print(f"   ‚ùå {origem} ‚Üí {destino}: Sem rota dispon√≠vel")

# Interface de menu interativo
def menu_principal():
    sistema = SistemaIVERN()
    while True:
        print("\n" + "="*60 + "\nüåø SISTEMA IVERN - COORDENA√á√ÉO DE QUEIMADAS üåø\n" + "="*60)
        print("1. üÜï Inserir nova ocorr√™ncia\n2. üö® Atender pr√≥xima ocorr√™ncia\n3. üìù Registrar a√ß√µes realizadas")
        print("4. üìã Listar hist√≥rico de equipe\n5. üîÑ Atualizar status de ocorr√™ncia\n6. üìä Gerar relat√≥rio por regi√£o")
        print("7. üé≤ Simular chamadas aleat√≥rias\n8. ‚úÖ Finalizar ocorr√™ncia\n9. üîç Buscar ocorr√™ncias por regi√£o")
        print("10. üó∫Ô∏è Listar regi√µes por prioridade\n11. ‚Ü©Ô∏è Desfazer √∫ltima a√ß√£o\n12. üñ•Ô∏è Status do sistema")
        print("13. üõ£Ô∏è Calcular rota otimizada\n14. üó∫Ô∏è Planejar atendimento m√∫ltiplo\n15. üåê Visualizar mapa de conex√µes\n0. üö™ Sair")
        
        try:
            opcao = input("Escolha uma op√ß√£o: ").strip()
            if opcao == "1":
                sistema.inserir_nova_ocorrencia(
                    input("Regi√£o: "),
                    int(input("Severidade (1-10): ")),
                    (float(input("Latitude: ")), float(input("Longitude: "))),
                    input("Descri√ß√£o (opcional): ")
                )
            elif opcao == "2": sistema.atender_proxima_ocorrencia()
            elif opcao == "3": sistema.registrar_acoes_realizadas(int(input("ID da ocorr√™ncia: ")), [a.strip() for a in input("A√ß√µes realizadas (separadas por ;): ").split(';') if a.strip()])
            elif opcao == "4": sistema.listar_historico_equipe(int(input("ID da equipe: ")))
            elif opcao == "5": sistema.atualizar_status_ocorrencia(int(input("ID da ocorr√™ncia: ")), input("Novo status (PENDENTE/EM_ATENDIMENTO/RESOLVIDO): ").upper())
            elif opcao == "6": sistema.gerar_relatorio_regiao(input("Regi√£o (deixe vazio para todas): ").strip() or None)
            elif opcao == "7": sistema.simular_chamadas_aleatorias(int(input("Quantidade de chamadas para simular (padr√£o 5): ") or "5"))
            elif opcao == "8": sistema.finalizar_ocorrencia(int(input("ID da ocorr√™ncia para finalizar: ")))
            elif opcao == "9": sistema.buscar_ocorrencias_por_regiao(input("Nome da regi√£o para buscar: "))
            elif opcao == "10": sistema.listar_regioes_por_prioridade()
            elif opcao == "11": sistema.desfazer_ultima_acao()
            elif opcao == "12": sistema.status_sistema()
            elif opcao == "13": sistema.calcular_rota_otima(input("Regi√£o de origem: "), input("Regi√£o de destino: "))
            elif opcao == "14": sistema.planejar_atendimento_multiplo(input("Regi√£o base para planejamento: "))
            elif opcao == "15": sistema.visualizar_mapa_conexoes()
            elif opcao == "0": print("üëã Encerrando Sistema IVERN. At√© logo!"); break
            else: print("‚ùå Op√ß√£o inv√°lida!")
        except ValueError: print("‚ùå Entrada inv√°lida! Tente novamente.")
        except KeyboardInterrupt: print("\nüëã Sistema encerrado pelo usu√°rio."); break
        except Exception as e: print(f"‚ùå Erro inesperado: {e}")

# Demonstra√ß√£o automatizada do sistema
def exemplo_automatizado():
    print("üöÄ EXECUTANDO EXEMPLO AUTOMATIZADO DO SISTEMA IVERN")
    print("="*60)
    
    sistema = SistemaIVERN()
    
    # Cen√°rio de teste completo
    print("\n1Ô∏è‚É£ Inserindo ocorr√™ncias...")
    sistema.inserir_nova_ocorrencia("Mata Atl√¢ntica Sul", 8, (-23.5505, -46.6333), "Inc√™ndio de grande porte")
    sistema.inserir_nova_ocorrencia("Cerrado Central", 5, (-15.7942, -47.8822), "Queimada controlada descontrolada")
    sistema.inserir_nova_ocorrencia("Amaz√¥nia Norte", 10, (-3.1190, -60.0217), "Emerg√™ncia cr√≠tica")
    
    print("\n2Ô∏è‚É£ Atendendo ocorr√™ncias por prioridade...")
    sistema.atender_proxima_ocorrencia()
    sistema.atender_proxima_ocorrencia()
    
    print("\n3Ô∏è‚É£ Registrando a√ß√µes...")
    sistema.registrar_acoes_realizadas(1, ["Equipe deslocada", "Per√≠metro estabelecido", "Combate iniciado"])
    
    print("\n4Ô∏è‚É£ Gerando relat√≥rio...")
    sistema.gerar_relatorio_regiao()
    
    print("\n5Ô∏è‚É£ Consultando hist√≥rico...")
    sistema.listar_historico_equipe(1)
    
    sistema.status_sistema()
    
    print("\n6Ô∏è‚É£ Simulando chamadas aleat√≥rias...")
    sistema.simular_chamadas_aleatorias(3)
    
    # Demonstra√ß√£o das funcionalidades de roteamento
    print("\n7Ô∏è‚É£ Demonstrando funcionalidades do grafo...")
    sistema.debug_grafo()
    sistema.calcular_rota_otima("Mata Atl√¢ntica Sul", "Amaz√¥nia Norte")
    sistema.planejar_atendimento_multiplo("Cerrado Central")
    sistema.visualizar_mapa_conexoes()
    
    print("\n‚úÖ Exemplo automatizado conclu√≠do!")

# Ponto de entrada do programa
if __name__ == "__main__":
    print("üåø BEM-VINDO AO SISTEMA IVERN üåø\nSistema de Coordena√ß√£o de Resposta a Queimadas")
    modo = input("Escolha o modo:\n1. Menu interativo\n2. Exemplo automatizado\nOp√ß√£o: ").strip()
    if modo == "2":
        exemplo_automatizado()
    else:
        menu_principal()