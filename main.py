import heapq
import random
import datetime
from collections import deque
from typing import Dict, List, Optional, Tuple
import json

# ==================== ESTRUTURAS DE DADOS ====================

class No:
    """N√≥ para lista ligada e √°rvore"""
    def __init__(self, dados):
        self.dados = dados
        self.proximo = None
        self.esquerda = None
        self.direita = None

class ListaLigada:
    """Lista ligada para hist√≥rico de a√ß√µes"""
    def __init__(self):
        self.cabeca = None
        self.tamanho = 0
    
    def inserir_inicio(self, dados):
        novo_no = No(dados)
        novo_no.proximo = self.cabeca
        self.cabeca = novo_no
        self.tamanho += 1
    
    def listar(self):
        elementos = []
        atual = self.cabeca
        while atual:
            elementos.append(atual.dados)
            atual = atual.proximo
        return elementos
    
    def buscar(self, criterio):
        """Busca elementos que atendem ao crit√©rio"""
        atual = self.cabeca
        resultados = []
        while atual:
            if criterio(atual.dados):
                resultados.append(atual.dados)
            atual = atual.proximo
        return resultados

class ArvoreRegiao:
    """√Årvore bin√°ria para organizar regi√µes por prioridade"""
    def __init__(self):
        self.raiz = None
    
    def inserir(self, regiao, prioridade):
        if not self.raiz:
            self.raiz = No({'regiao': regiao, 'prioridade': prioridade})
        else:
            self._inserir_recursivo(self.raiz, regiao, prioridade)
    
    def _inserir_recursivo(self, no, regiao, prioridade):
        if prioridade < no.dados['prioridade']:
            if no.esquerda is None:
                no.esquerda = No({'regiao': regiao, 'prioridade': prioridade})
            else:
                self._inserir_recursivo(no.esquerda, regiao, prioridade)
        else:
            if no.direita is None:
                no.direita = No({'regiao': regiao, 'prioridade': prioridade})
            else:
                self._inserir_recursivo(no.direita, regiao, prioridade)
    
    def busca_binaria_regiao(self, prioridade_alvo):
        """Busca bin√°ria por prioridade na √°rvore"""
        return self._buscar_recursivo(self.raiz, prioridade_alvo)
    
    def _buscar_recursivo(self, no, prioridade_alvo):
        if not no:
            return None
        
        if no.dados['prioridade'] == prioridade_alvo:
            return no.dados
        elif prioridade_alvo < no.dados['prioridade']:
            return self._buscar_recursivo(no.esquerda, prioridade_alvo)
        else:
            return self._buscar_recursivo(no.direita, prioridade_alvo)
    
    def listar_em_ordem(self):
        """Percurso em ordem da √°rvore"""
        resultado = []
        self._em_ordem_recursivo(self.raiz, resultado)
        return resultado
    
    def _em_ordem_recursivo(self, no, resultado):
        if no:
            self._em_ordem_recursivo(no.esquerda, resultado)
            resultado.append(no.dados)
            self._em_ordem_recursivo(no.direita, resultado)

class GrafoRegioes:
    """Grafo para representar conex√µes entre regi√µes e calcular rotas otimizadas"""
    def __init__(self):
        self.vertices = {}  # regi√£o -> {regi√£o_vizinha: distancia/tempo}
        self.coordenadas = {}  # regi√£o -> (lat, lon)
    
    def adicionar_vertice(self, regiao, coordenadas=None):
        """Adiciona uma regi√£o ao grafo"""
        if regiao not in self.vertices:
            self.vertices[regiao] = {}
            if coordenadas:
                self.coordenadas[regiao] = coordenadas
    
    def adicionar_aresta(self, regiao1, regiao2, peso):
        """Adiciona conex√£o entre duas regi√µes com peso (dist√¢ncia/tempo)"""
        if regiao1 not in self.vertices:
            self.adicionar_vertice(regiao1)
        if regiao2 not in self.vertices:
            self.adicionar_vertice(regiao2)
        
        # Grafo n√£o direcionado
        self.vertices[regiao1][regiao2] = peso
        self.vertices[regiao2][regiao1] = peso
    
    def dijkstra(self, origem, destino):
        """Algoritmo de Dijkstra para encontrar o menor caminho"""
        if origem not in self.vertices or destino not in self.vertices:
            return None, float('inf')
        
        # Inicializa√ß√£o
        distancias = {vertice: float('inf') for vertice in self.vertices}
        distancias[origem] = 0
        predecessores = {vertice: None for vertice in self.vertices}
        visitados = set()
        
        # Heap de prioridade: (dist√¢ncia, v√©rtice)
        heap = [(0, origem)]
        
        while heap:
            dist_atual, vertice_atual = heapq.heappop(heap)
            
            if vertice_atual in visitados:
                continue
                
            visitados.add(vertice_atual)
            
            if vertice_atual == destino:
                break
            
            # Examinar vizinhos
            for vizinho, peso in self.vertices[vertice_atual].items():
                if vizinho not in visitados:
                    nova_distancia = dist_atual + peso
                    
                    if nova_distancia < distancias[vizinho]:
                        distancias[vizinho] = nova_distancia
                        predecessores[vizinho] = vertice_atual
                        heapq.heappush(heap, (nova_distancia, vizinho))
        
        # Reconstruir caminho
        caminho = []
        vertice_atual = destino
        while vertice_atual is not None:
            caminho.append(vertice_atual)
            vertice_atual = predecessores[vertice_atual]
        
        caminho.reverse()
        
        if caminho[0] != origem:
            return None, float('inf')  # N√£o h√° caminho
        
        return caminho, distancias[destino]
    
    def encontrar_rotas_multiplas(self, origem, destinos):
        """Encontra rotas otimizadas para m√∫ltiplos destinos"""
        rotas = {}
        for destino in destinos:
            caminho, distancia = self.dijkstra(origem, destino)
            rotas[destino] = {
                'caminho': caminho,
                'distancia': distancia,
                'tempo_estimado': distancia * 0.5  # Estimativa: 0.5h por unidade
            }
        return rotas
    
    def listar_conexoes(self):
        """Lista todas as conex√µes do grafo"""
        print("\nüó∫Ô∏è MAPA DE CONEX√ïES ENTRE REGI√ïES:")
        print("-" * 50)
        for regiao, conexoes in self.vertices.items():
            print(f"üìç {regiao}:")
            for vizinho, peso in conexoes.items():
                print(f"   ‚Üí {vizinho} (dist√¢ncia: {peso} unidades)")
            print()

# ==================== CLASSES PRINCIPAIS ====================

class Ocorrencia:
    """Representa uma ocorr√™ncia de queimada"""
    def __init__(self, id_ocorrencia, regiao, severidade, coordenadas, descricao=""):
        self.id = id_ocorrencia
        self.regiao = regiao
        self.severidade = severidade  # 1-10 (10 = mais severo)
        self.coordenadas = coordenadas
        self.descricao = descricao
        self.timestamp = datetime.datetime.now()
        self.status = "PENDENTE"  # PENDENTE, EM_ATENDIMENTO, RESOLVIDO
        self.equipe_responsavel = None
        self.acoes_realizadas = []
    
    def __lt__(self, other):
        # Para heap de prioridade (menor valor = maior prioridade)
        return self.severidade > other.severidade
    
    def __str__(self):
        return f"Ocorr√™ncia {self.id} - {self.regiao} (Severidade: {self.severidade})"

class Equipe:
    """Representa uma equipe de combate"""
    def __init__(self, id_equipe, nome, especializacao):
        self.id = id_equipe
        self.nome = nome
        self.especializacao = especializacao  # "TERRESTRE", "AEREA", "RESGATE"
        self.disponivel = True
        self.localizacao_atual = None
        self.historico_acoes = ListaLigada()
    
    def registrar_acao(self, acao):
        """Registra uma a√ß√£o no hist√≥rico da equipe"""
        registro = {
            'timestamp': datetime.datetime.now(),
            'acao': acao,
            'equipe_id': self.id
        }
        self.historico_acoes.inserir_inicio(registro)

class SistemaIVERN:
    """Sistema principal de coordena√ß√£o de resposta a queimadas"""
    
    def __init__(self):
        # Heap para prioriza√ß√£o de ocorr√™ncias
        self.fila_prioridade = []
        
        # Pilha para a√ß√µes de desfazer
        self.pilha_desfazer = deque()
        
        # Fila para processamento sequencial
        self.fila_processamento = deque()
        
        # √Årvore para organiza√ß√£o de regi√µes
        self.arvore_regioes = ArvoreRegiao()
        
        # Grafo para otimiza√ß√£o de rotas
        self.grafo_regioes = GrafoRegioes()
        
        # Dicion√°rios para busca eficiente O(1)
        self.ocorrencias_ativas = {}  # id -> Ocorrencia
        self.equipes = {}  # id -> Equipe
        self.regioes_risco = {}  # regiao -> nivel_risco
        
        # Contadores
        self.proximo_id_ocorrencia = 1
        self.proximo_id_equipe = 1
        
        # Inicializar dados de exemplo
        self._inicializar_sistema()
    
    def _inicializar_sistema(self):
        """Inicializa o sistema com dados de exemplo"""
        # Criar equipes
        self.adicionar_equipe("Brigada Florestal Alpha", "TERRESTRE")
        self.adicionar_equipe("Squadr√£o A√©reo Beta", "AEREA")
        self.adicionar_equipe("Equipe Resgate Gamma", "RESGATE")
        
        # Definir regi√µes de risco
        regioes = [
            ("Mata Atl√¢ntica Sul", 8),
            ("Cerrado Central", 6),
            ("Amaz√¥nia Norte", 9),
            ("Pantanal", 7),
            ("Caatinga", 5)
        ]
        
        for regiao, prioridade in regioes:
            self.regioes_risco[regiao] = prioridade
            self.arvore_regioes.inserir(regiao, prioridade)
        
        # Inicializar grafo de regi√µes
        self._inicializar_grafo_regioes()
    
    def _inicializar_grafo_regioes(self):
        """Inicializa o grafo com conex√µes entre regi√µes"""
        # Adicionar regi√µes com coordenadas aproximadas
        regioes_coords = {
            "Mata Atl√¢ntica Sul": (-23.5, -46.6),
            "Cerrado Central": (-15.8, -47.9),
            "Amaz√¥nia Norte": (-3.1, -60.0),
            "Pantanal": (-19.9, -56.1),
            "Caatinga": (-9.7, -40.5)
        }
        
        for regiao, coords in regioes_coords.items():
            self.grafo_regioes.adicionar_vertice(regiao, coords)
        
        # Adicionar conex√µes (dist√¢ncias aproximadas em unidades)
        conexoes = [
            ("Mata Atl√¢ntica Sul", "Cerrado Central", 12),
            ("Cerrado Central", "Pantanal", 8),
            ("Cerrado Central", "Amaz√¥nia Norte", 15),
            ("Amaz√¥nia Norte", "Caatinga", 20),
            ("Pantanal", "Caatinga", 18),
            ("Mata Atl√¢ntica Sul", "Pantanal", 10),
            ("Cerrado Central", "Caatinga", 14)
        ]
        
        for regiao1, regiao2, distancia in conexoes:
            self.grafo_regioes.adicionar_aresta(regiao1, regiao2, distancia)
    
    # ==================== OPERA√á√ïES PRINCIPAIS ====================
    
    def inserir_nova_ocorrencia(self, regiao, severidade, coordenadas, descricao=""):
        """Insere nova ocorr√™ncia no sistema"""
        ocorrencia = Ocorrencia(
            self.proximo_id_ocorrencia,
            regiao,
            severidade,
            coordenadas,
            descricao
        )
        
        # Adicionar ao heap de prioridade
        heapq.heappush(self.fila_prioridade, ocorrencia)
        
        # Adicionar √† fila de processamento
        self.fila_processamento.append(ocorrencia)
        
        # Adicionar ao dicion√°rio para busca r√°pida
        self.ocorrencias_ativas[ocorrencia.id] = ocorrencia
        
        # Registrar a√ß√£o na pilha de desfazer
        self.pilha_desfazer.append(('INSERIR_OCORRENCIA', ocorrencia.id))
        
        self.proximo_id_ocorrencia += 1
        
        print(f"‚úÖ Nova ocorr√™ncia registrada: {ocorrencia}")
        return ocorrencia.id
    
    def atender_proxima_ocorrencia(self):
        """Atende a pr√≥xima ocorr√™ncia com maior prioridade"""
        if not self.fila_prioridade:
            print("‚ùå N√£o h√° ocorr√™ncias pendentes")
            return None
        
        # Pegar ocorr√™ncia de maior prioridade (heap)
        ocorrencia = heapq.heappop(self.fila_prioridade)
        
        # Buscar equipe dispon√≠vel adequada
        equipe = self._encontrar_melhor_equipe(ocorrencia)
        
        if equipe:
            ocorrencia.status = "EM_ATENDIMENTO"
            ocorrencia.equipe_responsavel = equipe.id
            equipe.disponivel = False
            
            acao = f"Iniciado atendimento da ocorr√™ncia {ocorrencia.id} em {ocorrencia.regiao}"
            equipe.registrar_acao(acao)
            
            # Registrar na pilha de desfazer
            self.pilha_desfazer.append(('ATENDER_OCORRENCIA', ocorrencia.id, equipe.id))
            
            print(f"üö® Atendimento iniciado: {ocorrencia} por {equipe.nome}")
            return ocorrencia.id
        else:
            # Recolocar na fila se n√£o h√° equipe dispon√≠vel
            heapq.heappush(self.fila_prioridade, ocorrencia)
            print("‚ö†Ô∏è Nenhuma equipe dispon√≠vel no momento")
            return None
    
    def registrar_acoes_realizadas(self, id_ocorrencia, acoes):
        """Registra a√ß√µes realizadas em uma ocorr√™ncia"""
        if id_ocorrencia not in self.ocorrencias_ativas:
            print(f"‚ùå Ocorr√™ncia {id_ocorrencia} n√£o encontrada")
            return False
        
        ocorrencia = self.ocorrencias_ativas[id_ocorrencia]
        ocorrencia.acoes_realizadas.extend(acoes)
        
        if ocorrencia.equipe_responsavel:
            equipe = self.equipes[ocorrencia.equipe_responsavel]
            for acao in acoes:
                equipe.registrar_acao(f"Ocorr√™ncia {id_ocorrencia}: {acao}")
        
        print(f"üìù A√ß√µes registradas para ocorr√™ncia {id_ocorrencia}")
        return True
    
    def finalizar_ocorrencia(self, id_ocorrencia):
        """Finaliza uma ocorr√™ncia e libera a equipe"""
        if id_ocorrencia not in self.ocorrencias_ativas:
            print(f"‚ùå Ocorr√™ncia {id_ocorrencia} n√£o encontrada")
            return False
        
        ocorrencia = self.ocorrencias_ativas[id_ocorrencia]
        ocorrencia.status = "RESOLVIDO"
        
        if ocorrencia.equipe_responsavel:
            equipe = self.equipes[ocorrencia.equipe_responsavel]
            equipe.disponivel = True
            equipe.registrar_acao(f"Finalizada ocorr√™ncia {id_ocorrencia}")
        
        # Remove da lista de ativas
        del self.ocorrencias_ativas[id_ocorrencia]
        
        print(f"‚úÖ Ocorr√™ncia {id_ocorrencia} finalizada")
        return True
    
    def listar_historico_equipe(self, id_equipe):
        """Lista o hist√≥rico completo de uma equipe"""
        if id_equipe not in self.equipes:
            print(f"‚ùå Equipe {id_equipe} n√£o encontrada")
            return []
        
        equipe = self.equipes[id_equipe]
        historico = equipe.historico_acoes.listar()
        
        print(f"\nüìã Hist√≥rico da {equipe.nome}:")
        print("-" * 50)
        for i, registro in enumerate(historico, 1):
            timestamp = registro['timestamp'].strftime("%d/%m/%Y %H:%M:%S")
            print(f"{i}. [{timestamp}] {registro['acao']}")
        
        return historico
    
    def atualizar_status_ocorrencia(self, id_ocorrencia, novo_status):
        """Atualiza o status de uma ocorr√™ncia"""
        if id_ocorrencia not in self.ocorrencias_ativas:
            print(f"‚ùå Ocorr√™ncia {id_ocorrencia} n√£o encontrada")
            return False
        
        status_validos = ["PENDENTE", "EM_ATENDIMENTO", "RESOLVIDO"]
        if novo_status not in status_validos:
            print(f"‚ùå Status inv√°lido. Use: {', '.join(status_validos)}")
            return False
        
        ocorrencia = self.ocorrencias_ativas[id_ocorrencia]
        status_anterior = ocorrencia.status
        ocorrencia.status = novo_status
        
        self.pilha_desfazer.append(('ATUALIZAR_STATUS', id_ocorrencia, status_anterior))
        
        print(f"üîÑ Status da ocorr√™ncia {id_ocorrencia} atualizado: {status_anterior} ‚Üí {novo_status}")
        return True
    
    def gerar_relatorio_regiao(self, regiao=None):
        """Gera relat√≥rio de atendimento por regi√£o"""
        print(f"\nüìä RELAT√ìRIO DE ATENDIMENTO{' - ' + regiao if regiao else ''}")
        print("=" * 60)
        
        # Contar ocorr√™ncias por regi√£o
        contadores = {}
        total_ocorrencias = 0
        
        # Processar ocorr√™ncias ativas
        for ocorrencia in self.ocorrencias_ativas.values():
            if regiao is None or ocorrencia.regiao == regiao:
                if ocorrencia.regiao not in contadores:
                    contadores[ocorrencia.regiao] = {'ativas': 0, 'severidade_media': 0, 'total_severidade': 0}
                contadores[ocorrencia.regiao]['ativas'] += 1
                contadores[ocorrencia.regiao]['total_severidade'] += ocorrencia.severidade
                total_ocorrencias += 1
        
        # Calcular m√©dias e exibir
        for reg, dados in contadores.items():
            if dados['ativas'] > 0:
                dados['severidade_media'] = dados['total_severidade'] / dados['ativas']
            
            risco = self.regioes_risco.get(reg, 0)
            print(f"üåç {reg}:")
            print(f"   ‚Ä¢ Ocorr√™ncias ativas: {dados['ativas']}")
            print(f"   ‚Ä¢ Severidade m√©dia: {dados['severidade_media']:.1f}")
            print(f"   ‚Ä¢ N√≠vel de risco: {risco}/10")
            print()
        
        print(f"üìà Total de ocorr√™ncias ativas: {total_ocorrencias}")
        
        # Mostrar estado das equipes
        print("\nüë• STATUS DAS EQUIPES:")
        print("-" * 30)
        for equipe in self.equipes.values():
            status = "üü¢ Dispon√≠vel" if equipe.disponivel else "üî¥ Em atendimento"
            print(f"‚Ä¢ {equipe.nome} ({equipe.especializacao}): {status}")
    
    def simular_chamadas_aleatorias(self, quantidade=5):
        """Simula chamadas aleat√≥rias com severidade crescente"""
        print(f"\nüé≤ SIMULANDO {quantidade} CHAMADAS ALEAT√ìRIAS")
        print("=" * 50)
        
        regioes_disponiveis = list(self.regioes_risco.keys())
        
        for i in range(quantidade):
            regiao = random.choice(regioes_disponiveis)
            # Severidade crescente com alguma aleatoriedade
            severidade = min(10, 3 + i + random.randint(0, 2))
            
            # Coordenadas aleat√≥rias
            lat = round(random.uniform(-30, 5), 6)
            lon = round(random.uniform(-70, -35), 6)
            coordenadas = (lat, lon)
            
            descricoes = [
                "Fuma√ßa avistada por morador local",
                "Foco de inc√™ndio detectado por sat√©lite",
                "Queimada n√£o controlada reportada",
                "Inc√™ndio florestal em expans√£o",
                "Emerg√™ncia ambiental cr√≠tica"
            ]
            
            descricao = random.choice(descricoes)
            
            id_ocorrencia = self.inserir_nova_ocorrencia(regiao, severidade, coordenadas, descricao)
            
            # Simular delay entre chamadas
            if i < quantidade - 1:
                import time
                time.sleep(0.5)
    
    # ==================== OPERA√á√ïES AUXILIARES ====================
    
    def adicionar_equipe(self, nome, especializacao):
        """Adiciona nova equipe ao sistema"""
        equipe = Equipe(self.proximo_id_equipe, nome, especializacao)
        self.equipes[equipe.id] = equipe
        self.proximo_id_equipe += 1
        return equipe.id
    
    def _encontrar_melhor_equipe(self, ocorrencia):
        """Encontra a melhor equipe dispon√≠vel para a ocorr√™ncia"""
        equipes_disponiveis = [e for e in self.equipes.values() if e.disponivel]
        
        if not equipes_disponiveis:
            return None
        
        # Priorizar por especializa√ß√£o
        for equipe in equipes_disponiveis:
            if ocorrencia.severidade >= 8 and equipe.especializacao == "AEREA":
                return equipe
            elif ocorrencia.severidade >= 6 and equipe.especializacao == "TERRESTRE":
                return equipe
        
        # Retornar qualquer equipe dispon√≠vel
        return equipes_disponiveis[0]
    
    def desfazer_ultima_acao(self):
        """Desfaz a √∫ltima a√ß√£o usando a pilha"""
        if not self.pilha_desfazer:
            print("‚ùå Nenhuma a√ß√£o para desfazer")
            return False
        
        acao = self.pilha_desfazer.pop()
        
        if acao[0] == 'ATUALIZAR_STATUS':
            _, id_ocorrencia, status_anterior = acao
            if id_ocorrencia in self.ocorrencias_ativas:
                self.ocorrencias_ativas[id_ocorrencia].status = status_anterior
                print(f"‚Ü©Ô∏è Status da ocorr√™ncia {id_ocorrencia} revertido para {status_anterior}")
        
        # Adicionar mais casos conforme necess√°rio
        return True
    
    def buscar_ocorrencias_por_regiao(self, regiao):
        """Busca ocorr√™ncias por regi√£o usando busca bin√°ria na √°rvore"""
        # Primeiro, encontrar a prioridade da regi√£o
        regiao_info = None
        for r, p in self.regioes_risco.items():
            if r == regiao:
                regiao_info = self.arvore_regioes.busca_binaria_regiao(p)
                break
        
        if not regiao_info:
            print(f"‚ùå Regi√£o {regiao} n√£o encontrada")
            return []
        
        # Buscar ocorr√™ncias da regi√£o
        ocorrencias_regiao = [
            occ for occ in self.ocorrencias_ativas.values() 
            if occ.regiao == regiao
        ]
        
        print(f"üîç Encontradas {len(ocorrencias_regiao)} ocorr√™ncias em {regiao}")
        return ocorrencias_regiao
    
    def listar_regioes_por_prioridade(self):
        """Lista regi√µes ordenadas por prioridade usando √°rvore"""
        regioes_ordenadas = self.arvore_regioes.listar_em_ordem()
        
        print("\nüó∫Ô∏è REGI√ïES POR PRIORIDADE:")
        print("-" * 40)
        for regiao_info in regioes_ordenadas:
            print(f"‚Ä¢ {regiao_info['regiao']} (Prioridade: {regiao_info['prioridade']})")
    
    def status_sistema(self):
        """Exibe status geral do sistema"""
        print("\nüñ•Ô∏è STATUS DO SISTEMA IVERN")
        print("=" * 40)
        print(f"‚Ä¢ Ocorr√™ncias ativas: {len(self.ocorrencias_ativas)}")
        print(f"‚Ä¢ Ocorr√™ncias na fila: {len(self.fila_prioridade)}")
        print(f"‚Ä¢ Equipes dispon√≠veis: {sum(1 for e in self.equipes.values() if e.disponivel)}")
        print(f"‚Ä¢ Total de equipes: {len(self.equipes)}")
        print(f"‚Ä¢ A√ß√µes na pilha de desfazer: {len(self.pilha_desfazer)}")
    
    def calcular_rota_otima(self, regiao_origem, regiao_destino):
        """Calcula a rota mais eficiente entre duas regi√µes"""
        caminho, distancia = self.grafo_regioes.dijkstra(regiao_origem, regiao_destino)
        
        if caminho is None:
            print(f"‚ùå N√£o h√° rota dispon√≠vel entre {regiao_origem} e {regiao_destino}")
            return None
        
        tempo_estimado = distancia * 0.5  # 0.5 horas por unidade de dist√¢ncia
        
        print(f"\nüõ£Ô∏è ROTA OTIMIZADA: {regiao_origem} ‚Üí {regiao_destino}")
        print("=" * 60)
        print(f"üìç Caminho: {' ‚Üí '.join(caminho)}")
        print(f"üìè Dist√¢ncia total: {distancia} unidades")
        print(f"‚è±Ô∏è Tempo estimado: {tempo_estimado:.1f} horas")
        print(f"üöÅ Paradas intermedi√°rias: {len(caminho) - 2}")
        
        return {
            'caminho': caminho,
            'distancia': distancia,
            'tempo_estimado': tempo_estimado
        }
    
    def planejar_atendimento_multiplo(self, regiao_base):
        """Planeja rotas para atender m√∫ltiplas ocorr√™ncias a partir de uma base"""
        # Coletar regi√µes com ocorr√™ncias ativas
        regioes_com_ocorrencias = list(set(occ.regiao for occ in self.ocorrencias_ativas.values()))
        
        if not regioes_com_ocorrencias:
            print("‚ùå N√£o h√° ocorr√™ncias ativas para planejar rotas")
            return None
        
        if regiao_base not in self.grafo_regioes.vertices:
            print(f"‚ùå Regi√£o base {regiao_base} n√£o encontrada no mapa")
            return None
        
        # Remover regi√£o base da lista se estiver presente
        if regiao_base in regioes_com_ocorrencias:
            regioes_com_ocorrencias.remove(regiao_base)
        
        if not regioes_com_ocorrencias:
            print("‚ùå Todas as ocorr√™ncias est√£o na regi√£o base")
            return None
        
        # Calcular rotas para todas as regi√µes
        rotas = self.grafo_regioes.encontrar_rotas_multiplas(regiao_base, regioes_com_ocorrencias)
        
        print(f"\nüó∫Ô∏è PLANEJAMENTO DE ATENDIMENTO M√öLTIPLO")
        print(f"üìç Base de opera√ß√µes: {regiao_base}")
        print("=" * 60)
        
        # Ordenar por prioridade (dist√¢ncia + severidade das ocorr√™ncias)
        rotas_priorizadas = []
        for regiao, rota_info in rotas.items():
            # Calcular severidade m√©dia da regi√£o
            ocorrencias_regiao = [occ for occ in self.ocorrencias_ativas.values() if occ.regiao == regiao]
            severidade_media = sum(occ.severidade for occ in ocorrencias_regiao) / len(ocorrencias_regiao)
            
            # Score: maior severidade e menor dist√¢ncia = maior prioridade
            score = (severidade_media * 10) - rota_info['distancia']
            
            rotas_priorizadas.append({
                'regiao': regiao,
                'rota': rota_info,
                'ocorrencias': len(ocorrencias_regiao),
                'severidade_media': severidade_media,
                'score': score
            })
        
        # Ordenar por score (maior primeiro)
        rotas_priorizadas.sort(key=lambda x: x['score'], reverse=True)
        
        print("üéØ ORDEM DE ATENDIMENTO RECOMENDADA:")
        print("-" * 40)
        for i, info in enumerate(rotas_priorizadas, 1):
            print(f"{i}. {info['regiao']}")
            print(f"   üìç Rota: {' ‚Üí '.join(info['rota']['caminho'])}")
            print(f"   üìè Dist√¢ncia: {info['rota']['distancia']} unidades")
            print(f"   ‚è±Ô∏è Tempo: {info['rota']['tempo_estimado']:.1f}h")
            print(f"   üî• Ocorr√™ncias: {info['ocorrencias']} (severidade m√©dia: {info['severidade_media']:.1f})")
            print(f"   üéØ Score de prioridade: {info['score']:.1f}")
            print()
        
        return rotas_priorizadas
    
    def visualizar_mapa_conexoes(self):
        """Visualiza o mapa de conex√µes entre regi√µes"""
        self.grafo_regioes.listar_conexoes()
        
        # Mostrar estat√≠sticas do grafo
        total_regioes = len(self.grafo_regioes.vertices)
        total_conexoes = sum(len(conexoes) for conexoes in self.grafo_regioes.vertices.values()) // 2
        
        print(f"üìä ESTAT√çSTICAS DO MAPA:")
        print(f"   ‚Ä¢ Total de regi√µes: {total_regioes}")
        print(f"   ‚Ä¢ Total de conex√µes: {total_conexoes}")
        print(f"   ‚Ä¢ Conectividade m√©dia: {total_conexoes * 2 / total_regioes:.1f} conex√µes por regi√£o")

# ==================== FUN√á√ÉO PRINCIPAL E MENU ====================

def menu_principal():
    """Menu interativo principal"""
    sistema = SistemaIVERN()
    
    while True:
        print("\n" + "="*60)
        print("üåø SISTEMA IVERN - COORDENA√á√ÉO DE QUEIMADAS üåø")
        print("="*60)
        print("1. üÜï Inserir nova ocorr√™ncia")
        print("2. üö® Atender pr√≥xima ocorr√™ncia (maior prioridade)")
        print("3. üìù Registrar a√ß√µes realizadas")
        print("4. üìã Listar hist√≥rico de equipe")
        print("5. üîÑ Atualizar status de ocorr√™ncia")
        print("6. üìä Gerar relat√≥rio por regi√£o")
        print("7. üé≤ Simular chamadas aleat√≥rias")
        print("8. ‚úÖ Finalizar ocorr√™ncia")
        print("9. üîç Buscar ocorr√™ncias por regi√£o")
        print("10. üó∫Ô∏è Listar regi√µes por prioridade")
        print("11. ‚Ü©Ô∏è Desfazer √∫ltima a√ß√£o")
        print("12. üñ•Ô∏è Status do sistema")
        print("13. üõ£Ô∏è Calcular rota otimizada entre regi√µes")
        print("14. üó∫Ô∏è Planejar atendimento m√∫ltiplo")
        print("15. üåê Visualizar mapa de conex√µes")
        print("0. üö™ Sair")
        print("-"*60)
        
        try:
            opcao = input("Escolha uma op√ß√£o: ").strip()
            
            if opcao == "1":
                print("\n--- NOVA OCORR√äNCIA ---")
                regiao = input("Regi√£o: ")
                severidade = int(input("Severidade (1-10): "))
                lat = float(input("Latitude: "))
                lon = float(input("Longitude: "))
                descricao = input("Descri√ß√£o (opcional): ")
                
                sistema.inserir_nova_ocorrencia(regiao, severidade, (lat, lon), descricao)
            
            elif opcao == "2":
                sistema.atender_proxima_ocorrencia()
            
            elif opcao == "3":
                id_occ = int(input("ID da ocorr√™ncia: "))
                acoes = input("A√ß√µes realizadas (separadas por ;): ").split(';')
                acoes = [acao.strip() for acao in acoes if acao.strip()]
                sistema.registrar_acoes_realizadas(id_occ, acoes)
            
            elif opcao == "4":
                id_equipe = int(input("ID da equipe: "))
                sistema.listar_historico_equipe(id_equipe)
            
            elif opcao == "5":
                id_occ = int(input("ID da ocorr√™ncia: "))
                status = input("Novo status (PENDENTE/EM_ATENDIMENTO/RESOLVIDO): ").upper()
                sistema.atualizar_status_ocorrencia(id_occ, status)
            
            elif opcao == "6":
                regiao = input("Regi√£o (deixe vazio para todas): ").strip()
                if not regiao:
                    regiao = None
                sistema.gerar_relatorio_regiao(regiao)
            
            elif opcao == "7":
                qtd = int(input("Quantidade de chamadas para simular (padr√£o 5): ") or "5")
                sistema.simular_chamadas_aleatorias(qtd)
            
            elif opcao == "8":
                id_occ = int(input("ID da ocorr√™ncia para finalizar: "))
                sistema.finalizar_ocorrencia(id_occ)
            
            elif opcao == "9":
                regiao = input("Nome da regi√£o para buscar: ")
                sistema.buscar_ocorrencias_por_regiao(regiao)
            
            elif opcao == "10":
                sistema.listar_regioes_por_prioridade()
            
            elif opcao == "11":
                sistema.desfazer_ultima_acao()
            
            elif opcao == "12":
                sistema.status_sistema()
            
            elif opcao == "13":
                origem = input("Regi√£o de origem: ")
                destino = input("Regi√£o de destino: ")
                sistema.calcular_rota_otima(origem, destino)
            
            elif opcao == "14":
                base = input("Regi√£o base para planejamento: ")
                sistema.planejar_atendimento_multiplo(base)
            
            elif opcao == "15":
                sistema.visualizar_mapa_conexoes()
            
            elif opcao == "0":
                print("üëã Encerrando Sistema IVERN. At√© logo!")
                break
            
            else:
                print("‚ùå Op√ß√£o inv√°lida!")
        
        except ValueError:
            print("‚ùå Entrada inv√°lida! Tente novamente.")
        except KeyboardInterrupt:
            print("\nüëã Sistema encerrado pelo usu√°rio.")
            break
        except Exception as e:
            print(f"‚ùå Erro inesperado: {e}")

# ==================== EXEMPLO DE USO AUTOMATIZADO ====================

def exemplo_automatizado():
    """Exemplo automatizado do sistema"""
    print("üöÄ EXECUTANDO EXEMPLO AUTOMATIZADO DO SISTEMA IVERN")
    print("="*60)
    
    sistema = SistemaIVERN()
    
    # 1. Inserir algumas ocorr√™ncias
    print("\n1Ô∏è‚É£ Inserindo ocorr√™ncias...")
    sistema.inserir_nova_ocorrencia("Mata Atl√¢ntica Sul", 8, (-23.5505, -46.6333), "Inc√™ndio de grande porte")
    sistema.inserir_nova_ocorrencia("Cerrado Central", 5, (-15.7942, -47.8822), "Queimada controlada descontrolada")
    sistema.inserir_nova_ocorrencia("Amaz√¥nia Norte", 10, (-3.1190, -60.0217), "Emerg√™ncia cr√≠tica")
    
    # 2. Atender ocorr√™ncias
    print("\n2Ô∏è‚É£ Atendendo ocorr√™ncias por prioridade...")
    sistema.atender_proxima_ocorrencia()
    sistema.atender_proxima_ocorrencia()
    
    # 3. Registrar a√ß√µes
    print("\n3Ô∏è‚É£ Registrando a√ß√µes...")
    sistema.registrar_acoes_realizadas(1, ["Equipe deslocada", "Per√≠metro estabelecido", "Combate iniciado"])
    
    # 4. Relat√≥rio
    print("\n4Ô∏è‚É£ Gerando relat√≥rio...")
    sistema.gerar_relatorio_regiao()
    
    # 5. Hist√≥rico
    print("\n5Ô∏è‚É£ Consultando hist√≥rico...")
    sistema.listar_historico_equipe(1)
    
    # 6. Status do sistema
    sistema.status_sistema()
    
    # 7. Simular mais chamadas
    print("\n6Ô∏è‚É£ Simulando chamadas aleat√≥rias...")
    sistema.simular_chamadas_aleatorias(3)
    
    print("\n‚úÖ Exemplo automatizado conclu√≠do!")

if __name__ == "__main__":
    print("üåø BEM-VINDO AO SISTEMA IVERN üåø")
    print("Sistema de Coordena√ß√£o de Resposta a Queimadas")
    print()
    
    modo = input("Escolha o modo:\n1. Menu interativo\n2. Exemplo automatizado\nOp√ß√£o: ").strip()
    
    if modo == "2":
        exemplo_automatizado()
    else:
        menu_principal()