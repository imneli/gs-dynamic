import heapq
import random
import datetime
from collections import deque
from typing import Dict, List, Optional, Tuple

class No:
    def __init__(self, dados):
        self.dados, self.proximo, self.esquerda, self.direita = dados, None, None, None

class ListaLigada:
    def __init__(self):
        self.cabeca, self.tamanho = None, 0
    
    def inserir_inicio(self, dados):
        novo_no = No(dados)
        novo_no.proximo, self.cabeca, self.tamanho = self.cabeca, novo_no, self.tamanho + 1
    
    def listar(self):
        elementos, atual = [], self.cabeca
        while atual:
            elementos.append(atual.dados)
            atual = atual.proximo
        return elementos

class ArvoreRegiao:
    def __init__(self):
        self.raiz = None
    
    def inserir(self, regiao, prioridade):
        if not self.raiz:
            self.raiz = No({'regiao': regiao, 'prioridade': prioridade})
        else:
            self._inserir_recursivo(self.raiz, regiao, prioridade)
    
    def _inserir_recursivo(self, no, regiao, prioridade):
        lado = 'esquerda' if prioridade < no.dados['prioridade'] else 'direita'
        if getattr(no, lado) is None:
            setattr(no, lado, No({'regiao': regiao, 'prioridade': prioridade}))
        else:
            self._inserir_recursivo(getattr(no, lado), regiao, prioridade)
    
    def busca_binaria_regiao(self, prioridade_alvo):
        return self._buscar_recursivo(self.raiz, prioridade_alvo)
    
    def _buscar_recursivo(self, no, prioridade_alvo):
        if not no: return None
        if no.dados['prioridade'] == prioridade_alvo: return no.dados
        return self._buscar_recursivo(no.esquerda if prioridade_alvo < no.dados['prioridade'] else no.direita, prioridade_alvo)
    
    def listar_em_ordem(self):
        resultado = []
        self._em_ordem_recursivo(self.raiz, resultado)
        return resultado
    
    def _em_ordem_recursivo(self, no, resultado):
        if no:
            self._em_ordem_recursivo(no.esquerda, resultado)
            resultado.append(no.dados)
            self._em_ordem_recursivo(no.direita, resultado)

class GrafoRegioes:
    def __init__(self):
        self.vertices, self.coordenadas = {}, {}
    
    def adicionar_vertice(self, regiao, coordenadas=None):
        if regiao not in self.vertices:
            self.vertices[regiao] = {}
            if coordenadas: self.coordenadas[regiao] = coordenadas
    
    def adicionar_aresta(self, regiao1, regiao2, peso):
        self.adicionar_vertice(regiao1), self.adicionar_vertice(regiao2)
        self.vertices[regiao1][regiao2] = self.vertices[regiao2][regiao1] = peso
    
    def dijkstra(self, origem, destino):
        if origem not in self.vertices or destino not in self.vertices: return None, float('inf')
        
        distancias, predecessores, visitados = {v: float('inf') for v in self.vertices}, {v: None for v in self.vertices}, set()
        distancias[origem], heap = 0, [(0, origem)]
        
        while heap:
            dist_atual, vertice_atual = heapq.heappop(heap)
            if vertice_atual in visitados: continue
            visitados.add(vertice_atual)
            if vertice_atual == destino: break
            
            for vizinho, peso in self.vertices[vertice_atual].items():
                if vizinho not in visitados and (nova_dist := dist_atual + peso) < distancias[vizinho]:
                    distancias[vizinho], predecessores[vizinho] = nova_dist, vertice_atual
                    heapq.heappush(heap, (nova_dist, vizinho))
        
        caminho, vertice_atual = [], destino
        while vertice_atual is not None:
            caminho.append(vertice_atual)
            vertice_atual = predecessores[vertice_atual]
        
        return (caminho[::-1], distancias[destino]) if caminho and caminho[0] == origem else (None, float('inf'))
    
    def listar_conexoes(self):
        print("\nüó∫Ô∏è MAPA DE CONEX√ïES ENTRE REGI√ïES:\n" + "-" * 50)
        for regiao, conexoes in self.vertices.items():
            print(f"üìç {regiao}:")
            for vizinho, peso in conexoes.items():
                print(f"   ‚Üí {vizinho} (dist√¢ncia: {peso} unidades)")
            print()

class Ocorrencia:
    def __init__(self, id_ocorrencia, regiao, severidade, coordenadas, descricao=""):
        self.id, self.regiao, self.severidade = id_ocorrencia, regiao, severidade
        self.coordenadas, self.descricao = coordenadas, descricao
        self.timestamp, self.status = datetime.datetime.now(), "PENDENTE"
        self.equipe_responsavel, self.acoes_realizadas = None, []
    
    def __lt__(self, other): return self.severidade > other.severidade
    def __str__(self): return f"Ocorr√™ncia {self.id} - {self.regiao} (Severidade: {self.severidade})"

class Equipe:
    def __init__(self, id_equipe, nome, especializacao):
        self.id, self.nome, self.especializacao = id_equipe, nome, especializacao
        self.disponivel, self.localizacao_atual, self.historico_acoes = True, None, ListaLigada()
    
    def registrar_acao(self, acao):
        self.historico_acoes.inserir_inicio({
            'timestamp': datetime.datetime.now(),
            'acao': acao,
            'equipe_id': self.id
        })

class SistemaIVERN:
    def __init__(self):
        self.fila_prioridade, self.pilha_desfazer, self.fila_processamento = [], deque(), deque()
        self.arvore_regioes, self.grafo_regioes = ArvoreRegiao(), GrafoRegioes()
        self.ocorrencias_ativas, self.equipes, self.regioes_risco = {}, {}, {}
        self.proximo_id_ocorrencia, self.proximo_id_equipe = 1, 1
        self._inicializar_sistema()
    
    def _inicializar_sistema(self):
        for nome, esp in [("Brigada Florestal Alpha", "TERRESTRE"), ("Squadr√£o A√©reo Beta", "AEREA"), ("Equipe Resgate Gamma", "RESGATE")]:
            self.adicionar_equipe(nome, esp)
        
        for regiao, prioridade in [("Mata Atl√¢ntica Sul", 8), ("Cerrado Central", 6), ("Amaz√¥nia Norte", 9), ("Pantanal", 7), ("Caatinga", 5)]:
            self.regioes_risco[regiao], self.arvore_regioes.inserir(regiao, prioridade)
        
        regioes_coords = {
            "Mata Atl√¢ntica Sul": (-23.5, -46.6),
            "Cerrado Central": (-15.8, -47.9),
            "Amaz√¥nia Norte": (-3.1, -60.0),
            "Pantanal": (-19.9, -56.1),
            "Caatinga": (-9.7, -40.5)
        }
        
        for regiao, coords in regioes_coords.items():
            self.grafo_regioes.adicionar_vertice(regiao, coords)
        
        for regiao1, regiao2, distancia in [
            ("Mata Atl√¢ntica Sul", "Cerrado Central", 12),
            ("Cerrado Central", "Pantanal", 8),
            ("Cerrado Central", "Amaz√¥nia Norte", 15),
            ("Amaz√¥nia Norte", "Caatinga", 20),
            ("Pantanal", "Caatinga", 18),
            ("Mata Atl√¢ntica Sul", "Pantanal", 10),
            ("Cerrado Central", "Caatinga", 14)
        ]:
            self.grafo_regioes.adicionar_aresta(regiao1, regiao2, distancia)
    
    def inserir_nova_ocorrencia(self, regiao, severidade, coordenadas, descricao=""):
        ocorrencia = Ocorrencia(self.proximo_id_ocorrencia, regiao, severidade, coordenadas, descricao)
        heapq.heappush(self.fila_prioridade, ocorrencia)
        self.fila_processamento.append(ocorrencia)
        self.ocorrencias_ativas[ocorrencia.id] = ocorrencia
        self.pilha_desfazer.append(('INSERIR_OCORRENCIA', ocorrencia.id))
        self.proximo_id_ocorrencia += 1
        print(f"‚úÖ Nova ocorr√™ncia registrada: {ocorrencia}")
        return ocorrencia.id
    
    def atender_proxima_ocorrencia(self):
        if not self.fila_prioridade:
            print("‚ùå N√£o h√° ocorr√™ncias pendentes")
            return None
        
        ocorrencia = heapq.heappop(self.fila_prioridade)
        if not (equipe := self._encontrar_melhor_equipe(ocorrencia)):
            heapq.heappush(self.fila_prioridade, ocorrencia)
            print("‚ö†Ô∏è Nenhuma equipe dispon√≠vel no momento")
            return None
        
        ocorrencia.status, ocorrencia.equipe_responsavel = "EM_ATENDIMENTO", equipe.id
        equipe.disponivel = False
        equipe.registrar_acao(f"Iniciado atendimento da ocorr√™ncia {ocorrencia.id} em {ocorrencia.regiao}")
        self.pilha_desfazer.append(('ATENDER_OCORRENCIA', ocorrencia.id, equipe.id))
        print(f"üö® Atendimento iniciado: {ocorrencia} por {equipe.nome}")
        return ocorrencia.id
    
    def _encontrar_melhor_equipe(self, ocorrencia):
        equipes_disponiveis = [e for e in self.equipes.values() if e.disponivel]
        return next((e for e in equipes_disponiveis if 
                   (ocorrencia.severidade >= 8 and e.especializacao == "AEREA") or
                   (ocorrencia.severidade >= 6 and e.especializacao == "TERRESTRE")), 
                   equipes_disponiveis[0] if equipes_disponiveis else None)

    def registrar_acoes_realizadas(self, id_ocorrencia, acoes):
        if id_ocorrencia not in self.ocorrencias_ativas:
            print(f"‚ùå Ocorr√™ncia {id_ocorrencia} n√£o encontrada")
            return False
        
        ocorrencia = self.ocorrencias_ativas[id_ocorrencia]
        ocorrencia.acoes_realizadas.extend(acoes)
        
        if ocorrencia.equipe_responsavel:
            for acao in acoes:
                self.equipes[ocorrencia.equipe_responsavel].registrar_acao(f"Ocorr√™ncia {id_ocorrencia}: {acao}")
        
        print(f"üìù A√ß√µes registradas para ocorr√™ncia {id_ocorrencia}")
        return True
    
    def finalizar_ocorrencia(self, id_ocorrencia):
        if id_ocorrencia not in self.ocorrencias_ativas:
            print(f"‚ùå Ocorr√™ncia {id_ocorrencia} n√£o encontrada")
            return False
        
        ocorrencia = self.ocorrencias_ativas[id_ocorrencia]
        ocorrencia.status = "RESOLVIDO"
        
        if ocorrencia.equipe_responsavel:
            equipe = self.equipes[ocorrencia.equipe_responsavel]
            equipe.disponivel, equipe.registrar_acao = True, f"Finalizada ocorr√™ncia {id_ocorrencia}"
        
        del self.ocorrencias_ativas[id_ocorrencia]
        print(f"‚úÖ Ocorr√™ncia {id_ocorrencia} finalizada")
        return True
    
    def listar_historico_equipe(self, id_equipe):
        if id_equipe not in self.equipes:
            print(f"‚ùå Equipe {id_equipe} n√£o encontrada")
            return []
        
        historico = self.equipes[id_equipe].historico_acoes.listar()
        print(f"\nüìã Hist√≥rico da {self.equipes[id_equipe].nome}:\n" + "-" * 50)
        for i, registro in enumerate(historico, 1):
            print(f"{i}. [{registro['timestamp'].strftime('%d/%m/%Y %H:%M:%S')}] {registro['acao']}")
        return historico
    
    def atualizar_status_ocorrencia(self, id_ocorrencia, novo_status):
        if id_ocorrencia not in self.ocorrencias_ativas:
            print(f"‚ùå Ocorr√™ncia {id_ocorrencia} n√£o encontrada")
            return False
        
        if novo_status not in ["PENDENTE", "EM_ATENDIMENTO", "RESOLVIDO"]:
            print("‚ùå Status inv√°lido. Use: PENDENTE, EM_ATENDIMENTO ou RESOLVIDO")
            return False
        
        ocorrencia = self.ocorrencias_ativas[id_ocorrencia]
        self.pilha_desfazer.append(('ATUALIZAR_STATUS', id_ocorrencia, ocorrencia.status))
        ocorrencia.status = novo_status
        print(f"üîÑ Status da ocorr√™ncia {id_ocorrencia} atualizado: {ocorrencia.status}")
        return True
    
    def gerar_relatorio_regiao(self, regiao=None):
        print(f"\nüìä RELAT√ìRIO DE ATENDIMENTO{' - ' + regiao if regiao else ''}\n" + "=" * 60)
        contadores = {}
        
        for ocorrencia in self.ocorrencias_ativas.values():
            if regiao is None or ocorrencia.regiao == regiao:
                if ocorrencia.regiao not in contadores:
                    contadores[ocorrencia.regiao] = {'ativas': 0, 'total_severidade': 0}
                contadores[ocorrencia.regiao]['ativas'] += 1
                contadores[ocorrencia.regiao]['total_severidade'] += ocorrencia.severidade
        
        for reg, dados in contadores.items():
            risco = self.regioes_risco.get(reg, 0)
            print(f"üåç {reg}:\n   ‚Ä¢ Ocorr√™ncias ativas: {dados['ativas']}\n   ‚Ä¢ Severidade m√©dia: {dados['total_severidade']/dados['ativas']:.1f}\n   ‚Ä¢ N√≠vel de risco: {risco}/10\n")
        
        print(f"üìà Total de ocorr√™ncias ativas: {sum(d['ativas'] for d in contadores.values())}")
        print("\nüë• STATUS DAS EQUIPES:\n" + "-" * 30)
        for equipe in self.equipes.values():
            print(f"‚Ä¢ {equipe.nome} ({equipe.especializacao}): {'üü¢ Dispon√≠vel' if equipe.disponivel else 'üî¥ Em atendimento'}")
    
    def simular_chamadas_aleatorias(self, quantidade=5):
        print(f"\nüé≤ SIMULANDO {quantidade} CHAMADAS ALEAT√ìRIAS\n" + "=" * 50)
        for i in range(quantidade):
            regiao = random.choice(list(self.regioes_risco.keys()))
            severidade = min(10, 3 + i + random.randint(0, 2))
            coordenadas = (round(random.uniform(-30, 5), 6), round(random.uniform(-70, -35), 6))
            descricao = random.choice([
                "Fuma√ßa avistada por morador local",
                "Foco de inc√™ndio detectado por sat√©lite",
                "Queimada n√£o controlada reportada",
                "Inc√™ndio florestal em expans√£o",
                "Emerg√™ncia ambiental cr√≠tica"
            ])
            self.inserir_nova_ocorrencia(regiao, severidade, coordenadas, descricao)
    
    def adicionar_equipe(self, nome, especializacao):
        equipe = Equipe(self.proximo_id_equipe, nome, especializacao)
        self.equipes[equipe.id], self.proximo_id_equipe = equipe, self.proximo_id_equipe + 1
        return equipe.id
    
    def desfazer_ultima_acao(self):
        if not self.pilha_desfazer:
            print("‚ùå Nenhuma a√ß√£o para desfazer")
            return False
        
        acao = self.pilha_desfazer.pop()
        if acao[0] == 'ATUALIZAR_STATUS' and acao[1] in self.ocorrencias_ativas:
            self.ocorrencias_ativas[acao[1]].status = acao[2]
            print(f"‚Ü©Ô∏è Status da ocorr√™ncia {acao[1]} revertido para {acao[2]}")
        return True
    
    def buscar_ocorrencias_por_regiao(self, regiao):
        ocorrencias_regiao = [occ for occ in self.ocorrencias_ativas.values() if occ.regiao == regiao]
        print(f"üîç Encontradas {len(ocorrencias_regiao)} ocorr√™ncias em {regiao}")
        return ocorrencias_regiao
    
    def listar_regioes_por_prioridade(self):
        print("\nüó∫Ô∏è REGI√ïES POR PRIORIDADE:\n" + "-" * 40)
        for regiao_info in self.arvore_regioes.listar_em_ordem():
            print(f"‚Ä¢ {regiao_info['regiao']} (Prioridade: {regiao_info['prioridade']})")
    
    def status_sistema(self):
        print("\nüñ•Ô∏è STATUS DO SISTEMA IVERN\n" + "=" * 40)
        print(f"‚Ä¢ Ocorr√™ncias ativas: {len(self.ocorrencias_ativas)}\n‚Ä¢ Ocorr√™ncias na fila: {len(self.fila_prioridade)}")
        print(f"‚Ä¢ Equipes dispon√≠veis: {sum(1 for e in self.equipes.values() if e.disponivel)}\n‚Ä¢ Total de equipes: {len(self.equipes)}")
        print(f"‚Ä¢ A√ß√µes na pilha de desfazer: {len(self.pilha_desfazer)}")
    
    def calcular_rota_otima(self, regiao_origem, regiao_destino):
        caminho, distancia = self.grafo_regioes.dijkstra(regiao_origem, regiao_destino)
        if caminho is None:
            print(f"‚ùå N√£o h√° rota dispon√≠vel entre {regiao_origem} e {regiao_destino}")
            return None
        
        print(f"\nüõ£Ô∏è ROTA OTIMIZADA: {regiao_origem} ‚Üí {regiao_destino}\n" + "=" * 60)
        print(f"üìç Caminho: {' ‚Üí '.join(caminho)}\nüìè Dist√¢ncia total: {distancia} unidades")
        print(f"‚è±Ô∏è Tempo estimado: {distancia * 0.5:.1f} horas\nüöÅ Paradas intermedi√°rias: {len(caminho) - 2}")
        return {'caminho': caminho, 'distancia': distancia, 'tempo_estimado': distancia * 0.5}
    
    def planejar_atendimento_multiplo(self, regiao_base):
        regioes_com_ocorrencias = list(set(occ.regiao for occ in self.ocorrencias_ativas.values() if occ.regiao != regiao_base))
        if not regioes_com_ocorrencias:
            print("‚ùå N√£o h√° ocorr√™ncias ativas para planejar rotas")
            return None
        
        if regiao_base not in self.grafo_regioes.vertices:
            print(f"‚ùå Regi√£o base {regiao_base} n√£o encontrada no mapa")
            return None
        
        rotas = {regiao: {'rota': self.grafo_regioes.dijkstra(regiao_base, regiao)} for regiao in regioes_com_ocorrencias}
        rotas_priorizadas = []
        
        for regiao, rota_info in rotas.items():
            ocorrencias_regiao = [occ for occ in self.ocorrencias_ativas.values() if occ.regiao == regiao]
            severidade_media = sum(occ.severidade for occ in ocorrencias_regiao) / len(ocorrencias_regiao)
            rotas_priorizadas.append({
                'regiao': regiao,
                'rota': {'caminho': rota_info['rota'][0], 'distancia': rota_info['rota'][1]},
                'ocorrencias': len(ocorrencias_regiao),
                'severidade_media': severidade_media,
                'score': (severidade_media * 10) - rota_info['rota'][1]
            })
        
        rotas_priorizadas.sort(key=lambda x: x['score'], reverse=True)
        print(f"\nüó∫Ô∏è PLANEJAMENTO DE ATENDIMENTO M√öLTIPLO\nüìç Base de opera√ß√µes: {regiao_base}\n" + "=" * 60)
        print("üéØ ORDEM DE ATENDIMENTO RECOMENDADA:\n" + "-" * 40)
        
        for i, info in enumerate(rotas_priorizadas, 1):
            print(f"{i}. {info['regiao']}\n   üìç Rota: {' ‚Üí '.join(info['rota']['caminho'])}")
            print(f"   üìè Dist√¢ncia: {info['rota']['distancia']} unidades\n   ‚è±Ô∏è Tempo: {info['rota']['distancia'] * 0.5:.1f}h")
            print(f"   üî• Ocorr√™ncias: {info['ocorrencias']} (severidade m√©dia: {info['severidade_media']:.1f})\n   üéØ Score de prioridade: {info['score']:.1f}\n")
        
        return rotas_priorizadas
    
    def visualizar_mapa_conexoes(self):
        self.grafo_regioes.listar_conexoes()
        total_regioes = len(self.grafo_regioes.vertices)
        print(f"üìä ESTAT√çSTICAS DO MAPA:\n   ‚Ä¢ Total de regi√µes: {total_regioes}")
        print(f"   ‚Ä¢ Total de conex√µes: {sum(len(c) for c in self.grafo_regioes.vertices.values()) // 2}")
        print(f"   ‚Ä¢ Conectividade m√©dia: {sum(len(c) for c in self.grafo_regioes.vertices.values()) / total_regioes:.1f} conex√µes por regi√£o")

def menu_principal():
    sistema = SistemaIVERN()
    while True:
        print("\n" + "="*60 + "\nüåø SISTEMA IVERN - COORDENA√á√ÉO DE QUEIMADAS üåø\n" + "="*60)
        print("1. üÜï Inserir nova ocorr√™ncia\n2. üö® Atender pr√≥xima ocorr√™ncia\n3. üìù Registrar a√ß√µes realizadas")
        print("4. üìã Listar hist√≥rico de equipe\n5. üîÑ Atualizar status de ocorr√™ncia\n6. üìä Gerar relat√≥rio por regi√£o")
        print("7. üé≤ Simular chamadas aleat√≥rias\n8. ‚úÖ Finalizar ocorr√™ncia\n9. üîç Buscar ocorr√™ncias por regi√£o")
        print("10. üó∫Ô∏è Listar regi√µes por prioridade\n11. ‚Ü©Ô∏è Desfazer √∫ltima a√ß√£o\n12. üñ•Ô∏è Status do sistema")
        print("13. üõ£Ô∏è Calcular rota otimizada\n14. üó∫Ô∏è Planejar atendimento m√∫ltiplo\n15. üåê Visualizar mapa de conex√µes\n0. üö™ Sair")
        
        try:
            opcao = input("Escolha uma op√ß√£o: ").strip()
            if opcao == "1":
                sistema.inserir_nova_ocorrencia(
                    input("Regi√£o: "),
                    int(input("Severidade (1-10): ")),
                    (float(input("Latitude: ")), float(input("Longitude: "))),
                    input("Descri√ß√£o (opcional): ")
                )
            elif opcao == "2": sistema.atender_proxima_ocorrencia()
            elif opcao == "3": sistema.registrar_acoes_realizadas(int(input("ID da ocorr√™ncia: ")), [a.strip() for a in input("A√ß√µes realizadas (separadas por ;): ").split(';') if a.strip()])
            elif opcao == "4": sistema.listar_historico_equipe(int(input("ID da equipe: ")))
            elif opcao == "5": sistema.atualizar_status_ocorrencia(int(input("ID da ocorr√™ncia: ")), input("Novo status (PENDENTE/EM_ATENDIMENTO/RESOLVIDO): ").upper())
            elif opcao == "6": sistema.gerar_relatorio_regiao(input("Regi√£o (deixe vazio para todas): ").strip() or None)
            elif opcao == "7": sistema.simular_chamadas_aleatorias(int(input("Quantidade de chamadas para simular (padr√£o 5): ") or "5"))
            elif opcao == "8": sistema.finalizar_ocorrencia(int(input("ID da ocorr√™ncia para finalizar: ")))
            elif opcao == "9": sistema.buscar_ocorrencias_por_regiao(input("Nome da regi√£o para buscar: "))
            elif opcao == "10": sistema.listar_regioes_por_prioridade()
            elif opcao == "11": sistema.desfazer_ultima_acao()
            elif opcao == "12": sistema.status_sistema()
            elif opcao == "13": sistema.calcular_rota_otima(input("Regi√£o de origem: "), input("Regi√£o de destino: "))
            elif opcao == "14": sistema.planejar_atendimento_multiplo(input("Regi√£o base para planejamento: "))
            elif opcao == "15": sistema.visualizar_mapa_conexoes()
            elif opcao == "0": print("üëã Encerrando Sistema IVERN. At√© logo!"); break
            else: print("‚ùå Op√ß√£o inv√°lida!")
        except ValueError: print("‚ùå Entrada inv√°lida! Tente novamente.")
        except KeyboardInterrupt: print("\nüëã Sistema encerrado pelo usu√°rio."); break
        except Exception as e: print(f"‚ùå Erro inesperado: {e}")

if __name__ == "__main__":
    print("üåø BEM-VINDO AO SISTEMA IVERN üåø\nSistema de Coordena√ß√£o de Resposta a Queimadas")
    menu_principal() if input("Escolha o modo:\n1. Menu interativo\n2. Exemplo automatizado\nOp√ß√£o: ").strip() == "1" else None